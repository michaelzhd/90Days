######C++变量的引用

在声明一个引用类型变量的时候必须同时初始化，即声明它代表哪一个变量。在声明变量b是变量a的引用后，在它们所在函数执行期间，该引用变量b始终与其代表的变量a相联系，不能再作为其他变量的引用（别名）。下面的用法不对：

	int a1,a2;
	int &b=a1;
	int &b=a2;//企图使b又变成a2的引用（别名）是不行的
	
######C++构造函数和复制构造函数的区别

- 在形式上

类名（形参列表）；//普通构造函数声明，如Box(int h,int w,int len);
类名（类名& 对象名）；//复制构造函数的声明，如Box(Box &b);

- 在建立对象时，实参类型不同

系统会根据实参的类型决定调用普通构造函数或复制构造函数。如：

	Box box1(12,15,16);//实参为整数，调用普通构造函数
	Box box2(box1);//实参是对象名，调用复制构造函数
	
- 在什么情况下被调用

普通构造函数在程序中建立对象时被调用。复制构造函数在用已有对象复制一个新对象时被调用，在以下3中情况下需要克隆对象：

1） 程序中需要新建一个对象，并用另一个同类的对象对它进行初始化，如上面所说的那样。

2）当函数的参数为类的对象时。在调用函数时需要将实参对象完整的传递给形参，也就是需要建立一个实参的拷贝，这就是按实参复制一个形参，系统是通过调用复制构造函数来实现的，这样能保证形参具有和实参完全相同的值。如：

	void func(Box b) //形参是类的对象
	{ }
	
	int main()
	{
		Box box1(12,15,18);
		func(box1);//实参是类的对象，调用函数时将复制一个新对象b
		return 0;
	}
	
3）函数的返回值是类的对象。在函数调用完毕将返回值带回函数调用处时。此时需要将函数中的对象渎职一个临时对象并传递给该函数的调用处。如：

	Box f()
	{
		Box box1(12,15,18);
		return box1;//返回值是Box类的对象
	}
	
	int main()
	{
		Box box2;//定义Box类的对象box2
		box2=f();//调用f函数，返回Box类的临时对象，并将它赋值给box2
	}
	
######C++ `static`数据成员该注意什么？



1） **静态数据成员不属于某一个对象，在为对象所分配的空间中不包括静态数据成员所占的空间。静态数据成员是在所有对象之外单独开辟空间。**只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间，他可以被引用。

2）**静态数据成员是在程序编译时被分配空间的，到程序结束时才释放空间**。它不随着对象的撤销而释放或者随着函数的结束而释放。

3）静态数据成员可以初始化，但是只能在类体外进行初始化。

	int Box::height=10;//表示对Box类中的静态数据成员初始化
	
不必在初始化语句中加`static`关键字。

4）静态数据成员的作用域只限于定义该类的作用域内，在此作用域内，可以通过类名和域作用符`::`引用静态数据成员，而不论类对象时候存在。

######C++`static`函数成员注意什么？

>说白了，`static`成员函数就是为了处理`static`成员数据而生的！

1）静态成员函数不是任何对象的组成部分，因此`static`成员函数没有`this`指针。所以，由此决定了静态成员函数不能访问本类中的非静态成员。
2）**注意：**作为C++程序员要养成良好的习惯：只有静态成员函数引用静态数据成员，而不引用非静态数据成员。这样思路清晰，逻辑清楚，不易出错。

######关于友元类`friend`的一些小说明

>话说，友元类或者友元函数可以很好的提高数据共享性，但是有时候也会稍微的破坏类的封装原则，这个适当的度要开发者自己把握。

1）友元的关系是单向的不是双向的。如果声明了B类是A类的友元类，不等于A类是B类的友元类，A类中的成员函数不能访问B类中的私有数据。

2）友元关系不能传递。如果B类是A类的友元类，C类是B类的友元类，不等于C类是A类的友元类。**如果想让C类是A类的友元类，应在A类中另外声明。**

**注意：**在实际工作中一般并不把整个类声明为友元类，而只将确实有需要的成员函数声明为友元函数，这样更安全一些。