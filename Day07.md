####Java的浅复制小实验

	class Shape
	{
		Shape(int x)
		{
			this.x=x;
		}
		void setShapeId(int x)
		{
			this.x=x;
		}
		int x;	
	}
	
首先写了以上这个小小的Shape类。下面是`main`方法：
		
	public static void main(String args[])
	{
	
		Shape shape=new Shape(10);
		System.out.println("shape.x="+shape.x);
		Shape shape2=shape;
		System.out.println("shape2.x="+shape2.x);
		shape.setShapeId(20);
		System.out.println("shape.x="+shape.x);
		System.out.println("shape2.x="+shape2.x);
	}
	
根据`main`方法的代码，`new`出一个Shape类，并且变量x的初始值为10，然后用这个实例去初始化另一个实例，那么这时，其实在堆中只分配了一个Shape类实例的内存空间，shape和shape2只是这个内存空间的引用，如果改变一个，将对两个变量都会产生影响，这就是浅拷贝。如果在Java中想实现深拷贝，那就要重载Object类的`clone()`方法。实验结果如下：

	shape.x=10
	shape2.x=10
	shape.x=20
	shape2.x=20
	
说明shape.setShapeId之后，不仅仅更改了shape的值，也更改了shape2的值。

##C++面向对象之继承

####动态绑定

在C++中要触发动态绑定要满足两个条件：

- 只有致死那个为虚函数的成员函数才能进行动态绑定，成员函数默认为虚函数，非虚函数不能进行动态绑定

- 必须通过基类函数的引用或者指针进行调用时

*因为可以使用基类类型的引用或者指针来指向基类类型的对象或者派生类类型的对象，所以，使用基类类型的引用或者指针的时候，不知道指针或引用所绑定的对象的类型*：**基类类型的引用或者指针可以引用基类类型对象，也可以引用派生类型对象。**


**注解：**

基类类型引用和指针的关键点在于**静态类型**（编译时确定）和**动态类型**（运行时确定）可能不同。

看下面的代码:

	void method(const Parent &item)
	{
		//do something
		item.do();
	}
	
在method方法中，调用其item形参的do函数，关于这个method函数要注意以下两点：

- 这个函数的形参是一个Parent的引用，但是也可以将Child对象传给它。

- 因为形参是引用且do函数是一个虚函数，所以对do函数的调用将在**运行时**确定，调用哪个版本的do函数将决定于传给method函数的实参。


**注解：**

在C++中，通过基类的引用（指针）调用虚函数的时候，将发生动态绑定。引用（或者指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或者指针）调用的虚函数在运行时确定，被调用的函数是引用（或者指针）所指对象的实际类型所定义的。

####派生类和虚函数

- 派生类一般会冲定义所继承的虚函数。如果派生类没有重定义某个虚函数，则使用基类中的版本。
- 派生类中的虚函数声明必须与基类中定义的方式完全匹配，但是有一个**例外：**返回对基类型的引用或者指针的虚函数，派生类中得虚函数可以返回积累函数所返回类型的派生类的引用或者指针。

**注解：**

一旦函数在基类中声明为虚函数，它就一直为虚函数，派生类无法给边该函数为虚函数这一事实。派生类重定义虚函数时，可以使用`vritual`保留字，但是这不是必须的。

####派生类对象包含基类对象作为子对象

- 派生类对象由多部分组成：派生类本身定义的（非static）成员加上由基类（非static）成员组成的子对象。

####用派生类对象对基类对象进行初始化或者复赋值的步骤

（可以通过定义复制构造函数或赋值操作符来实现）

- 将派生类对象转换为基类的引用，这就是讲一个基类类型的引用绑定到派生类对象上。

- 将该引用作为实参传给复制构造函数或者赋值操作符

- 那些操作符使用派生类的基类部分分别对调用构造函数或赋值的基类对象的成员进行初始化或者赋值
- 一旦操作符执行完毕，对象即为基类，它包含派生类的基类部分的副本，但是实参的派生部分被忽略。