#####swift `?`和 `!`

- ?  如果`?`前面的值不为`nil`，则继续执行`?`面的操作，如果为`nil`，则路过`?`后面的操作，避免了crash。


- ！ 确定`!`前面的值是非`nil`的，强制执行后面的操作，当然如果不加判断，前面的为`nil`时，就会crash掉。

>小提示：`swift`语言使用var定义变量，但和别的语言不同，`swift`里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错。

#算法导论期末复习

###Bellman-Ford算法:

>首先这个算法的时间复杂的是*O(VE)*

Bellman-Ford算法解决的是一般情况下的单元最短路径问题。边的权重可以是负值。给定带权重的有向图G=(V,E)和权重函数w:E->R,**Bellman-Ford算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路**。如果存在这样的一个环路，算法将告诉我们不存在解决方案，返回一个`false`。如果没有这种环路存在，算法将给出最短路径和它的权重。

Bellman-Ford算法返回`true`值当且仅当输入图不包含可以从源节点到达的权重为负值的环路。下面附上基本的伪代码：

- 用运行时间是O(V)的算法来对最短路径估计和前驱节点初始化

	
		INITIALIZE-SINGLE-SOURCE(G,s)
		
		1 for each vertex v属于G.V
		2 		v.d=无穷
		3		v.q=nil
		4 s.d=0
		
- 下面的算法是在O(1)时间内进行的松弛操作：


		RELEAX(u,v,w)
		
		1 if v.d > u.d + w(u,v)
		2		v.d = u.d + w(u,v)
		3 		v.q = u
		
		
- 最短路径和松弛操作的性质：


	1）**上界性质：**对于所有的节点v属于*V*，我们总是有v.d >= &(s,v)。一旦v.d的值达到$(s,v),那么v.d的值将不会发生变化。
	
	2）**非路径性质：**如果从节点s到节点v之间不存在路径，则总是有v.d = $(s,v) = 无穷大。
	
	
下面给出Belloman-Ford伪代码算法：

		BELLMAN-FORD(G,w,s)
		
		1 INITIALIZE-SINGLE-SOURCE(G,s)
		2 for i=1 to |G.V|-1
		3		for each edge(u,v) 属于 G.E
		4 			RELEAX(u,v,w)
		5 for each edge(u,v) 属于 G.E
		6 		if v.d > u.d + w(u,v)
		7			return false
		8 return true
		
**时间复杂度分析：**算法的第一行的初始化操作素需要的时间是O(V)，第2~4行循环的运行时间是O(E),而且要进行|V|-1次循环，第5~7行的for循环所需要的时间为O(E),所以算法的总时间为O(VE)。

**Bellman-Ford算法引理：**

- 假设G=(V,E)为一个带权重的源节点为s的有向图，其权重函数为w:E->R.假设图G不包含从源节点s就可以到达的权重为负值的环路。那么算法BELLMAN-FORD的第2~4行的for循环执行了|V|-1
次之后，对于所有从源节点s可以到达的节点v，我们有v.d = &(s,v)。


- 假设G=(V,E)为一个带权重的源节点为s的有向图，其权重函数为w:E->R.假设图G不包含从源节点s就可以到达的权重为负值的环路，则对于所有的节点v属于*V*,存在一条从源节点s到节点v的路径当且仅当BELLMAN-FORD算法终止时有v.d < 无穷大。



###Dijkstra算法

Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。其在运行的过程中维持的关键信息是一组节点集合S。从源节点s到集合S中的每个节点之前的最短路径已经被找到。算法重复从点集V-S中选择最短路径估计最小的节点u，将u加入到集合S,然后对所有从u发出的边进行松弛。在算法中，我们用一个**最小优先队列Q**来保存节点集合，每个节点的关键值为d。

下面是*Dijkstra*算法伪代码：


		DIJKSTRA(G,w,s)
		
		1 INITIALIZE-SINGLE-SOURCE(G,s)
		2 S = null
		3 Q = G.V
		4 while Q!=null
		5		u=EXTRACT-MIN(Q)
		6		S=S Union {u}
		7		for each vertex v属于 G.Adj[u]
		8			RELAX(u,v,w)


**解释：**

第1行执行的是例行的d值和q值的初始化

第2行将集合S初始化为一个空集

第3行对最小优先队列Q进行初始化，将所有节点V都放在该队列里

第4~8行的`while`循环的时，第5行从Q=V-S集合中抽取节点u，第6行将该节点加入到集合S里，从而继续保持不变式成立。（注意，在第一次`while`循环时，u=s。）节点u是集合V-S中所有节点最小的估计值。然后7~8行，我们对所有从源节点u出发的边(u,v)进行松弛操作。如果一条经过节点u的路径能够使得从源节点s到节点v的最短路径权重比当前的估计值更小，则我们对v.d的值和前驱u.q的值进行更新。

		
